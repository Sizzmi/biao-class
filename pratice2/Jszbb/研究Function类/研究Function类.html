<!-- **由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。** -->
<script>
  //function语句的定义方法
  function test1(arg1, arg2) {
    console.log("function语句的定义方法:", arg1 + arg2);
    return;
  }

  //函数直接量的定义方法
  var test2 = function (arg1, arg2) {
    console.log("函数直接量的定义方法:", arg1 + arg2);
    return;
  }

//构造函数的定义方法
// var test3 = new Function("arg1","arg2","console.log('构造函数的定义方法:',arg1+arg2)")//不推荐

// test2的变量中， function 关键字后面没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量 test2 即可以引用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。

// test3是使用 Function 构造函数。 Function 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。

// 从技术角度讲，test3是一个函数表达式。但是，不推荐使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。
</script>

<script>
  // **由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同**
  function sum(num1, num2) {
    return num1 + num2;
  }

  console.log(sum(10, 10));//20
  var anotherSum = sum;
  console.log(anotherSum(10, 10));//20
  sum = null;
  console.log(anotherSum(10, 10));//20

</script>
<!-- 以上代码首先定义了一个名为 sum() 的函数，用于求两个值的和。然后，又声明了变量 anotherSum ，并将其设置为与 sum 相等（将 sum 的值赋给 anotherSum ）。注意，使用不带圆括号的函数名是访问函数指针，而非调用函数。此时， anotherSum 和 sum 就都指向了同一个函数，因此 anotherSum() 也可以被调用并返回结果。即使将 sum 设置为 null ，让它与函数“断绝关系”，但仍然可以正常调用anotherSum() 。 -->

<!-- ### 二、JavaScript中的函数没有重载的概念 -->
<!-- 将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。 -->

<script>
  function addSomeNumber(num) {
    return num + 100;
  }
  function addSomeNumber(num) {
    return num + 200;
  }
  var result = addSomeNumber(100);//300 最终得到的结果是300；
  console.log(result);
    // 显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。

</script>

<script>
  var addSomeNumber = function (num) {
    return num + 100;
  };
  addSomeNumber = function (num) {//在这里再次给addSomeNumber赋值；
    return num + 200;
  };
  var result = addSomeNumber(100); //300
  console.log(result);
</script>

<!-- ### 三、函数声明与函数表达式 -->
<script>
  // 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。
  console.log(sum(10, 10));
  function sum(num1, num2) {
    return num1 + num2;
  }

  // 因为此时的var num；sum的值在上面调用的时候，值是undecided；只能写在函数表达式的后面 ；该为下面这种写法就可以了；
</script>

<script>
  console.log(sum(10, 10));//Uncaught TypeError: sum is not a function
  var sum = function (num1, num2) {
    return num1 + num2;
  }
</script>

<script>
  // 因为此时的var num；sum的值在上面调用的时候，值是undecided；只能写在函数表达式的后面 ；该为下面这种写法就可以了；
  var sum = function (num1, num2) {
    return num1 + num2;
  }
  console.log(sum(10, 10));
  // 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。

// > 也可以同时使用函数声明和函数表达式，例如 var sum = function sum(){} 。不过，这种语法在 Safari 中会导致错误。
</script>

<script>
  // ### 四、作为值的函数
  function callSomeFunction(someFunction, someArgument) {
    return someFunction(someArgument);
  }

  function add10(num) {
    return num + 10;
  }
  var result1 = callSomeFunction(add10, 10);//add10储存是是add10这个函数的内存地址
  console.log(result1);//20

  function getGreeting(name) {
    return "Hello" + name;
  }
  var result2 = callSomeFunction(getGreeting, "Word");
  console.log(result2);

  // 这里的 callSomeFunction() 函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给 callSomeFunction() 的是 add10 和 getGreeting ，而不是执行它们之后的结果。

</script>

<script>
  //  ##### 排序的思路；
  // 从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 sort() 方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，
  // 可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。

  function createComparisonFunction(propertyName) {
    return function (object1, object2) {
      var value1 = object1[propertyName];
      var value2 = object2[propertyName];
    }
    if (value1 < value2) {
      return - 1;
    } else if (value1 > value2) {
      return 1;
    } else {
      return 0;
    }
  }
  // 这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个 return 操作符。在内部函数接收到 propertyName 参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。
  var data = [{ name: "Zachary", age: 28 }, { name: "Nicholas", age: 29 }];
  data.sort(createComparisonFunction("name"));
  console.log(data[1].name);
  data.sort(createComparisonFunction("age"));
  console.log(data[0].name);
//  这里，我们创建了一个包含两个对象的数组 data 。其中，每个对象都包含一个 name 属性和一个age 属性。在默认情况下， sort() 方法会调用每个对象的 toString() 方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction("name") 方法创建了一个比较函数，以便按照每个对象的 name 属性值进行排序。而结果排在前面的第一项是 name为 "Nicholas" ， age 是 29 的对象。然后，我们又使用了 createComparisonFunction("age") 返回的比较函数，这次是按照对象的 age 属性排序。得到的结果是 name 值为 "Zachary" ， age 值是 28的对象排在了第一位。
</script>

<script>
  //   ### 五、函数内部属性

  // - arguments 在函数初始那里有研究
  // - arguments.callee  当前函数本身；
  // - this
  // - arguments.caller  这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null 



  // ##### arguments.callee

  // 在函数内部，有两个特殊的对象： arguments 和 this 。其中， arguments 是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。请看下面这个非常经典的阶乘函数

  function factorial(num) {
    if (num <= 1) {
      return 1;
    } else {
      return num * factorial(num - 1)
    }
  }


  // 定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee 。

  function factorial(num) {
    if (num <= 1) {
      return 1;
    } else {
      return num * arguments.callee(num - 1)
    }
  }
  var trueFactorial = factorial;
  factorial = function() {
    return 0;
  };
  
  console.log(trueFactorial(5));//120 1执行return1，2执行2*1，并存到arguments内用作下次，3执行3*2，4执行4*6，5执行5*24最终是120
  console.log(factorial(5));//0

  // 在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial 。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。
</script>

